<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<title>Películas Mejor Valoradas - Sunburst</title>
<style>
  #main {
    width: 100%;
    height: 900px;
    padding-top: 50px;
  }
</style>
</head>
<body>
<div id="main"></div>
<script src="https://cdn.jsdelivr.net/npm/echarts@5/dist/echarts.min.js"></script>
<script>
// Función para clasificar duración
function durationCategory(minutes) {
    minutes = parseInt(minutes);
    if (minutes < 30) return "Corto (<30 min)";
    if (minutes <= 120) return "Medio (30-90 min)";
    return "Largo (>90 min)";
}

// Función para clasificar rating
function ratingCategory(rating) {
    rating = parseFloat(rating);
    if (rating < 6) return "0-6";
    if (rating < 8) return "6-8";
    return "8-10";
}

// Cargar datos desde JSON
fetch('data.json')
.then(response => response.json())
.then(data => {
    // Filtrar películas con al menos 50 votos para evitar outliers
    const filtered = data.filter(d => parseInt(d.numVotes) >= 50);

    // Construir estructura jerárquica
    const sunburstData = {};

    function topCategories(data, topN = 4) {
        // data es un objeto con key=genre, value=count
        const entries = Object.entries(data);
        // Ordenar descendente por cantidad
        entries.sort((a, b) => b[1] - a[1]);

        const top = entries.slice(0, topN); // Top N
        const others = entries.slice(topN); // Las demás

        const result = {};
        top.forEach(([genre, count]) => result[genre] = count);

        if (others.length > 0) {
            // Agrupar las demás en "Otros"
            result["Otros"] = others.reduce((sum, [, count]) => sum + count, 0);
        }

        return result;
    }

    // Al construir la jerarquía:
    filtered.forEach(movie => {
        const genres = movie.genres.split(',');
        const runtimeCat = durationCategory(movie.runtimeMinutes);
        const ratingCat = ratingCategory(movie.averageRating);

        if (!sunburstData[ratingCat]) sunburstData[ratingCat] = {};
        if (!sunburstData[ratingCat][runtimeCat]) sunburstData[ratingCat][runtimeCat] = {};

        // Contar todas las categorías
        genres.forEach(genre => {
            if (!sunburstData[ratingCat][runtimeCat][genre])
                sunburstData[ratingCat][runtimeCat][genre] = 0;
            sunburstData[ratingCat][runtimeCat][genre] += 1;
        });
    });

    // Luego, aplicar topCategories a cada rating → duration:
    for (const rating in sunburstData) {
        for (const duration in sunburstData[rating]) {
            sunburstData[rating][duration] = topCategories(sunburstData[rating][duration], 4);
        }
    }


    // Convertir a formato de ECharts
    function convertToECharts(data) {
        return Object.keys(data).map(key => {
            const value = data[key];
            if (typeof value === 'number') {
                return { name: key, value: value };
            } else {
                return { name: key, children: convertToECharts(value) };
            }
        });
    }

    const option = {
      title: {
        text: 'Peliculas',
        subtext: 'Caracteristicas de peliculas categorizadas por rating',
        left: 'center',
        top: '0%'
      },
      series: {
        type: 'sunburst',
        data: convertToECharts(sunburstData),
        center: ['50%', '50%'],
        radius: [60, '90%'],
        itemStyle: {
          borderRadius: 7,
          borderWidth: 2
        },
        sort: null,
        levels: [
          {},
          {
            r0: '10%',
            r: '25%',
            itemStyle: {
              borderWidth: 2
            },
            label: {
              rotate: 'tangential'
            }
          },
          {
            r0: '25%',
            r: '60%',
            label: {
              align: 'right',
              padding: [0, 10, 0, 10]
            }
          },
          {
            r0: '60%',
            r: '65%',
            label: {
              fontSize: 10,
              position: 'outside',
              padding: 30,
              align: 'right',      // Alineación del texto
              formatter: '{b}',
              hideOverlap: true
            },
            labelLine: {
              show: true,      // Muestra línea de conexión (flecha)
              length: 15,      // Largo de la línea horizontal
              length2: 15,     // Largo de la línea radial
              smooth: true     // Línea curva suave
            },
            itemStyle: {
              borderWidth: 3
            }
          }
        ],
        emphasis: {
          itemStyle: {
            shadowBlur: 10,
            shadowOffsetX: 0,
            shadowColor: 'rgba(0, 0, 0, 0.5)'
          }
        }
      },
      tooltip: {
        formatter: info => `${info.name}: ${info.value} películas`
      }
    };

    const chart = echarts.init(document.getElementById('main'));
    chart.setOption(option);

});
</script>
</body>
</html>
